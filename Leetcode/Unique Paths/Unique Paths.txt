Unique Paths

Q.
There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.

Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.

The test cases are generated so that the answer will be less than or equal to 2 * 109.

 

Example 1:


Input: m = 3, n = 7
Output: 28
Example 2:

Input: m = 3, n = 2
Output: 3
Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:
1. Right -> Down -> Down
2. Down -> Down -> Right
3. Down -> Right -> Down
 

Constraints:

1 <= m, n <= 100
A.

// Using recursive solution #1
// class Solution {
// public:

//     int countPaths(int i,int j,int m,int n)
//     {
//         if(i==(n-1) && j==(m-1)) return 1;
//         if(i>=(n) || j>=m) return 0;
//         else return countPaths(i+1,j,m,n) + countPaths(i,j+1,m,n);
//     }

//     int uniquePaths(int m, int n) {
//         int ans = countPaths(0,0,m,n);
//         return ans;
//     }
// };

// Using DP second solution #2

// class Solution {
// public:

//     int countPaths(int i,int j,int m,int n,vector<vector<int>> &dp)
//     {
//         if(i==(n-1) && j==(m-1)) return 1;
//         if(i>=(n) || j>=m) return 0;

//         if(dp[i][j]!=-1) return dp[i][j];
//         else return dp[i][j] = countPaths(i+1,j,m,n,dp) + countPaths(i,j+1,m,n,dp);
//     }

//     int uniquePaths(int m, int n) {

//         vector<vector<int>> dp(n, vector<int>(m, -1)); 
//         int ans = countPaths(0,0,m,n,dp);
//         return ans;
//     }
// };

// using combinotronics solution #3

class Solution {
public:

    int uniquePaths(int m, int n) {

        int N = m+n-2;
        int r = min(m-1,n-1);
        long long ans = 1;
        for(int i=1;i<=r;i++)
           ans = ans * (N-r+i)/i;

        return (int)ans;
    }
};